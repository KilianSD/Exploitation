This level was quite nice to complete, tho you might get a few different disassembly result depending on the dissasembler used. I found IDA to be the most useful in this case but it was doable using any other disassembler (Binary Ninja, IDA, Ghidra, GDB...).

The program asks us for a serial key and then proceeds to modify and then check if it matches the expected key. At a really simplified level the program does the following on whatever serial you input `(xor -> sort -> xor -> swap)`.

Since we're reverse engineering and we know the expected key, we can take that expected key and do the operations backwards starting from swap `(swap -> xor -> sort -> xor)`.  Also note that logically a sort is not reversible, but we can avoid it and it will still work out so we remove this part of the equation `(swap -> xor -> xor)`. Running this on our expected key should result in a couple of non readable bytes, this is why i just extract the hex numbers, put it in a python list and send it to our program as bytes using the pwn library.

I used the following program to complete the challenge, it extracts the needed key.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#define EXPECTED_KEY_LENGTH 0x1c

int main(int argc, char** argv){
  std::vector<int64_t> EXPECTED_KEY = {
                          0xc4, 0x77, 0xca, 0x3b, 0xda, 0x72, 0xc7, 0x37,
                          0xc8, 0x7a, 0xc1, 0x2b, 0xdf, 0x68, 0x8f, 0x7a,
                          0x97, 0x3d, 0x87, 0x75, 0x8f, 0x3b, 0x81, 0x6c,
                          0x82, 0x2d, 0x94, 0x62
  };

  int t = EXPECTED_KEY[4];
  EXPECTED_KEY[4] = EXPECTED_KEY[10];
  EXPECTED_KEY[10] = t;

  for(int i = 0; i < 0x1c; i++){
    int v = 1 % 4;
    if(v == 3){
      EXPECTED_KEY[i] ^= 0x9e;
    } else if(v <= 3){
      if(v == 2){
        EXPECTED_KEY[i] ^= 0x6e;
      } else if(v <= 2){
        if(v == 1){
          EXPECTED_KEY[i] ^= 0xd4;
        } else {
          EXPECTED_KEY[i] ^= 0x64;
        }
      }
    }
  }

  int s = 0;
  for(int i = 0; i < 0x1c; i++){
    s = i % 2;
    if(s == 0){
      EXPECTED_KEY[i] ^= 0xcd;
    } else if(s == 1){
      EXPECTED_KEY[i] ^= 0x8a;
    }
  }

  std::for_each(EXPECTED_KEY.begin(), EXPECTED_KEY.end(), [](const int64_t& t){
                  std::cout << std::hex << "0x" << t << " ";
                });

  return 0;
}
```

And i sent the key to our program using the following python script.

```python
from pwn import *

KEY = [b"\x6d", b"\x29", b"\x69", b"\x2f", b"\x68", b"\x2c", b"\x64", b"\x23", b"\x61", b"\x24", b"\x79", b"\x3f", b"\x76", b"\x36", b"\x2c", b"\x6e", b"\x3e", b"\x63", b"\x24", b"\x61", b"\x26", b"\x65", b"\x22", b"\x78", b"\x2b", b"\x73", b"\x37", b"\x76"]
print(hex(len(KEY)))

io = process("/challenge/Reverse Engineering/7-1/babyrev_level7.1")
io.write(b"".join(KEY))
io.interactive()
```